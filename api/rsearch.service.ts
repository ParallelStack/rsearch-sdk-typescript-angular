/**
 * ParallelStack RSearch API
 * REST API Specification for ParallelStack RSearch API
 *
 * OpenAPI spec version: 1.1.0
 * Contact: team@parallelstack.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { CreateDocTypeFailure } from '../model/createDocTypeFailure';
import { CreateDocTypeSuccess } from '../model/createDocTypeSuccess';
import { CreateDocumentFailure } from '../model/createDocumentFailure';
import { CreateDocumentSuccess } from '../model/createDocumentSuccess';
import { CreateIndexFailure } from '../model/createIndexFailure';
import { CreateIndexSuccess } from '../model/createIndexSuccess';
import { DeleteDocumentFailure } from '../model/deleteDocumentFailure';
import { DeleteDocumentSuccess } from '../model/deleteDocumentSuccess';
import { DeleteIndexFailure } from '../model/deleteIndexFailure';
import { DeleteIndexSuccess } from '../model/deleteIndexSuccess';
import { Document } from '../model/document';
import { DocumentType } from '../model/documentType';
import { GetDocTypeFailure } from '../model/getDocTypeFailure';
import { GetDocTypeSuccess } from '../model/getDocTypeSuccess';
import { GetDocTypesFailure } from '../model/getDocTypesFailure';
import { GetDocTypesSuccess } from '../model/getDocTypesSuccess';
import { GetDocumentFailure } from '../model/getDocumentFailure';
import { GetDocumentSuccess } from '../model/getDocumentSuccess';
import { GetDocumentsFailure } from '../model/getDocumentsFailure';
import { GetDocumentsSuccess } from '../model/getDocumentsSuccess';
import { GetIndexFailure } from '../model/getIndexFailure';
import { GetIndexSuccess } from '../model/getIndexSuccess';
import { GetIndexesFailure } from '../model/getIndexesFailure';
import { GetIndexesSuccess } from '../model/getIndexesSuccess';
import { SearchFailure } from '../model/searchFailure';
import { SearchQuery } from '../model/searchQuery';
import { SearchSuccess } from '../model/searchSuccess';
import { SuggestFailure } from '../model/suggestFailure';
import { SuggestQuery } from '../model/suggestQuery';
import { SuggestSuccess } from '../model/suggestSuccess';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class RsearchService {

    protected basePath = 'https://api.parallelstack.com/api/rsearch/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * 
     * Creates &#x60;doc_id&#x60; in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     * @param documentDetails Details of the document
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addDocument(indexName: string, docTypeName: string, docId: string, documentDetails: Document, observe?: 'body', reportProgress?: boolean): Observable<CreateDocumentSuccess>;
    public addDocument(indexName: string, docTypeName: string, docId: string, documentDetails: Document, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateDocumentSuccess>>;
    public addDocument(indexName: string, docTypeName: string, docId: string, documentDetails: Document, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateDocumentSuccess>>;
    public addDocument(indexName: string, docTypeName: string, docId: string, documentDetails: Document, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling addDocument.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling addDocument.');
        }
        if (docId === null || docId === undefined) {
            throw new Error('Required parameter docId was null or undefined when calling addDocument.');
        }
        if (documentDetails === null || documentDetails === undefined) {
            throw new Error('Required parameter documentDetails was null or undefined when calling addDocument.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateDocumentSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}/documents/${encodeURIComponent(String(docId))}`,
            documentDetails,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Creates specific &#x60;document_type&#x60; in &#x60;index_name&#x60; with specified parameters. You should define the parameters correctly as per the getting started guide, else getting the right structure might be an issue.
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docTypeDetails Details of the document_type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addDocumentType(indexName: string, docTypeName: string, docTypeDetails: DocumentType, observe?: 'body', reportProgress?: boolean): Observable<CreateDocTypeSuccess>;
    public addDocumentType(indexName: string, docTypeName: string, docTypeDetails: DocumentType, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateDocTypeSuccess>>;
    public addDocumentType(indexName: string, docTypeName: string, docTypeDetails: DocumentType, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateDocTypeSuccess>>;
    public addDocumentType(indexName: string, docTypeName: string, docTypeDetails: DocumentType, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling addDocumentType.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling addDocumentType.');
        }
        if (docTypeDetails === null || docTypeDetails === undefined) {
            throw new Error('Required parameter docTypeDetails was null or undefined when calling addDocumentType.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<CreateDocTypeSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}`,
            docTypeDetails,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Creates &#x60;a new index&#x60;.
     * @param indexName Name of the index
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addIndex(indexName: string, observe?: 'body', reportProgress?: boolean): Observable<CreateIndexSuccess>;
    public addIndex(indexName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CreateIndexSuccess>>;
    public addIndex(indexName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CreateIndexSuccess>>;
    public addIndex(indexName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling addIndex.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.post<CreateIndexSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Deletes &#x60;doc_id&#x60; in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteDocument(indexName: string, docTypeName: string, docId: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteDocumentSuccess>;
    public deleteDocument(indexName: string, docTypeName: string, docId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteDocumentSuccess>>;
    public deleteDocument(indexName: string, docTypeName: string, docId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteDocumentSuccess>>;
    public deleteDocument(indexName: string, docTypeName: string, docId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling deleteDocument.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling deleteDocument.');
        }
        if (docId === null || docId === undefined) {
            throw new Error('Required parameter docId was null or undefined when calling deleteDocument.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteDocumentSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}/documents/${encodeURIComponent(String(docId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Deletes &#x60;an index&#x60; {index_name}
     * @param indexName Name of the index
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteIndex(indexName: string, observe?: 'body', reportProgress?: boolean): Observable<DeleteIndexSuccess>;
    public deleteIndex(indexName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DeleteIndexSuccess>>;
    public deleteIndex(indexName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DeleteIndexSuccess>>;
    public deleteIndex(indexName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling deleteIndex.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.delete<DeleteIndexSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Gets Suggestions from &#x60;doc_type_name&#x60; in &#x60;index_name&#x60; limited by the body params. Please ensure you refer the getting started guides, to get the format of the query right.
     * @param indexName Name of the index
     * @param docTypeName Name of the Document_type
     * @param suggest Details of the search query
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAdvancedDocTypeSuggestResults(indexName: string, docTypeName: string, suggest: SuggestQuery, observe?: 'body', reportProgress?: boolean): Observable<SuggestSuccess>;
    public getAdvancedDocTypeSuggestResults(indexName: string, docTypeName: string, suggest: SuggestQuery, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SuggestSuccess>>;
    public getAdvancedDocTypeSuggestResults(indexName: string, docTypeName: string, suggest: SuggestQuery, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SuggestSuccess>>;
    public getAdvancedDocTypeSuggestResults(indexName: string, docTypeName: string, suggest: SuggestQuery, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAdvancedDocTypeSuggestResults.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getAdvancedDocTypeSuggestResults.');
        }
        if (suggest === null || suggest === undefined) {
            throw new Error('Required parameter suggest was null or undefined when calling getAdvancedDocTypeSuggestResults.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<SuggestSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}/suggest`,
            suggest,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Gets Suggestions in &#x60;index_name&#x60; limited by the request body fields
     * @param indexName Name of the index
     * @param search Details of the search query
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAdvancedIndexSuggestResults(indexName: string, search: SuggestQuery, observe?: 'body', reportProgress?: boolean): Observable<SuggestSuccess>;
    public getAdvancedIndexSuggestResults(indexName: string, search: SuggestQuery, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SuggestSuccess>>;
    public getAdvancedIndexSuggestResults(indexName: string, search: SuggestQuery, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SuggestSuccess>>;
    public getAdvancedIndexSuggestResults(indexName: string, search: SuggestQuery, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAdvancedIndexSuggestResults.');
        }
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getAdvancedIndexSuggestResults.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<SuggestSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/suggest`,
            search,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Advanced Search which gets all documents in &#x60;index_name&#x60; for provided search criteria. Please ensure you refer the getting started guides, to get the format of the query right.
     * @param indexName Name of the index
     * @param docTypeName Name of the Document_type
     * @param search Details of the search query
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAdvancedSearchResults(indexName: string, docTypeName: string, search: SearchQuery, observe?: 'body', reportProgress?: boolean): Observable<SearchSuccess>;
    public getAdvancedSearchResults(indexName: string, docTypeName: string, search: SearchQuery, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchSuccess>>;
    public getAdvancedSearchResults(indexName: string, docTypeName: string, search: SearchQuery, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchSuccess>>;
    public getAdvancedSearchResults(indexName: string, docTypeName: string, search: SearchQuery, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAdvancedSearchResults.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getAdvancedSearchResults.');
        }
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getAdvancedSearchResults.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];
        let httpContentTypeSelected:string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set("Content-Type", httpContentTypeSelected);
        }

        return this.httpClient.post<SearchSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}/search`,
            search,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Gets &#x60;All document_types&#x60; present in &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllDocumentTypes(indexName: string, observe?: 'body', reportProgress?: boolean): Observable<GetDocTypesSuccess>;
    public getAllDocumentTypes(indexName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetDocTypesSuccess>>;
    public getAllDocumentTypes(indexName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetDocTypesSuccess>>;
    public getAllDocumentTypes(indexName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAllDocumentTypes.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetDocTypesSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Fetches all documents in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;. All the documents and hence careful with its use.
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllDocuments(indexName: string, docTypeName: string, observe?: 'body', reportProgress?: boolean): Observable<GetDocumentsSuccess>;
    public getAllDocuments(indexName: string, docTypeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetDocumentsSuccess>>;
    public getAllDocuments(indexName: string, docTypeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetDocumentsSuccess>>;
    public getAllDocuments(indexName: string, docTypeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAllDocuments.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getAllDocuments.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetDocumentsSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}/documents`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Fetches &#x60;All indexes&#x60; that the user has. Not recommended to be used in production code, as there isn&#39;t that big a Use case for listing all indexes!
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllIndexes(observe?: 'body', reportProgress?: boolean): Observable<GetIndexesSuccess>;
    public getAllIndexes(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetIndexesSuccess>>;
    public getAllIndexes(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetIndexesSuccess>>;
    public getAllIndexes(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetIndexesSuccess>(`${this.basePath}/indexes`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Basic Search which gets all documents in &#x60;index_name&#x60; for provided search criteria
     * @param indexName Name of the index
     * @param q Search Query
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getBasicSearchResults(indexName: string, q: string, observe?: 'body', reportProgress?: boolean): Observable<SearchSuccess>;
    public getBasicSearchResults(indexName: string, q: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SearchSuccess>>;
    public getBasicSearchResults(indexName: string, q: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SearchSuccess>>;
    public getBasicSearchResults(indexName: string, q: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getBasicSearchResults.');
        }
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling getBasicSearchResults.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (q !== undefined) {
            queryParameters = queryParameters.set('q', <any>q);
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<SearchSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/search`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Gets Suggestions from &#x60;doc_type_name&#x60; in &#x60;index_name&#x60;. Please ensure you refer the getting started guides, to get the format of the query right.
     * @param indexName Name of the index
     * @param docTypeName Name of the Document_type
     * @param q Details of the suggest query
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDocTypeSuggestResults(indexName: string, docTypeName: string, q: string, observe?: 'body', reportProgress?: boolean): Observable<SuggestSuccess>;
    public getDocTypeSuggestResults(indexName: string, docTypeName: string, q: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SuggestSuccess>>;
    public getDocTypeSuggestResults(indexName: string, docTypeName: string, q: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SuggestSuccess>>;
    public getDocTypeSuggestResults(indexName: string, docTypeName: string, q: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getDocTypeSuggestResults.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getDocTypeSuggestResults.');
        }
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling getDocTypeSuggestResults.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (q !== undefined) {
            queryParameters = queryParameters.set('q', <any>q);
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<SuggestSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}/suggest`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Fetches the document referenced by &#x60;doc_id&#x60; in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDocument(indexName: string, docTypeName: string, docId: string, observe?: 'body', reportProgress?: boolean): Observable<GetDocumentSuccess>;
    public getDocument(indexName: string, docTypeName: string, docId: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetDocumentSuccess>>;
    public getDocument(indexName: string, docTypeName: string, docId: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetDocumentSuccess>>;
    public getDocument(indexName: string, docTypeName: string, docId: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getDocument.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getDocument.');
        }
        if (docId === null || docId === undefined) {
            throw new Error('Required parameter docId was null or undefined when calling getDocument.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetDocumentSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}/documents/${encodeURIComponent(String(docId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Checks whether &#x60;document_type&#x60; in &#x60;index_name&#x60; exists
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDocumentType(indexName: string, docTypeName: string, observe?: 'body', reportProgress?: boolean): Observable<GetDocTypeSuccess>;
    public getDocumentType(indexName: string, docTypeName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetDocTypeSuccess>>;
    public getDocumentType(indexName: string, docTypeName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetDocTypeSuccess>>;
    public getDocumentType(indexName: string, docTypeName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getDocumentType.');
        }
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getDocumentType.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetDocTypeSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}/document_types/${encodeURIComponent(String(docTypeName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * Checks whether &#x60;a particular index&#x60; {index_name} exists
     * @param indexName Name of the index
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getIndex(indexName: string, observe?: 'body', reportProgress?: boolean): Observable<GetIndexSuccess>;
    public getIndex(indexName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<GetIndexSuccess>>;
    public getIndex(indexName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<GetIndexSuccess>>;
    public getIndex(indexName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getIndex.');
        }

        let headers = this.defaultHeaders;

        // authentication (authToken) required
        if (this.configuration.apiKeys["auth_token"]) {
            queryParameters = queryParameters.set('auth_token', this.configuration.apiKeys["auth_token"]);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKeys["X-RSearch-App-ID"]) {
            headers = headers.set('X-RSearch-App-ID', this.configuration.apiKeys["X-RSearch-App-ID"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        let httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set("Accept", httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        return this.httpClient.get<GetIndexSuccess>(`${this.basePath}/indexes/${encodeURIComponent(String(indexName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
