/**
 * ParallelStack RSearch API
 * REST API Specification for ParallelStack RSearch API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: team@parallelstack.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class RsearchApi {

    protected basePath = 'https://api.parallelstack.com/api/rsearch/v1';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Creates `doc_id` in `doc_type_name` for `index_name`
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     * @param documentDetails Details of the document
     */
    public addDocument(indexName: string, docTypeName: string, docId: string, documentDetails: any, extraHttpRequestParams?: any): Observable<models.InlineResponse2006> {
        return this.addDocumentWithHttpInfo(indexName, docTypeName, docId, documentDetails, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Creates specific `document_type` in `index_name` with specified parameters
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docTypeDetails Details of the document_type
     */
    public addDocumentType(indexName: string, docTypeName: string, docTypeDetails: any, extraHttpRequestParams?: any): Observable<models.InlineResponse2011> {
        return this.addDocumentTypeWithHttpInfo(indexName, docTypeName, docTypeDetails, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Creates `a new index`
     * @param indexName Name of the index
     */
    public addIndex(indexName: string, extraHttpRequestParams?: any): Observable<models.InlineResponse201> {
        return this.addIndexWithHttpInfo(indexName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Deletes `doc_id` in `doc_type_name` for `index_name`
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     */
    public deleteDocument(indexName: string, docTypeName: string, docId: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2007> {
        return this.deleteDocumentWithHttpInfo(indexName, docTypeName, docId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Deletes `an index` {index_name}
     * @param indexName Name of the index
     */
    public deleteIndex(indexName: string, extraHttpRequestParams?: any): Observable<models.InlineResponse202> {
        return this.deleteIndexWithHttpInfo(indexName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Advanced Search which gets all documents in `index_name` for provided search criteria
     * @param indexName Name of the index
     * @param docTypeName Name of the Document)type
     * @param search Details of the search query
     */
    public getAdvancedSearchResults(indexName: string, docTypeName: string, search: any, extraHttpRequestParams?: any): Observable<models.InlineResponse2008> {
        return this.getAdvancedSearchResultsWithHttpInfo(indexName, docTypeName, search, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Gets `All document_types` present in `index_name`
     * @param indexName Name of the index
     */
    public getAllDocumentTypes(indexName: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2002> {
        return this.getAllDocumentTypesWithHttpInfo(indexName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Fetches all documents in `doc_type_name` for `index_name`
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     */
    public getAllDocuments(indexName: string, docTypeName: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2004> {
        return this.getAllDocumentsWithHttpInfo(indexName, docTypeName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Fetches `All indexes`
     */
    public getAllIndexes(extraHttpRequestParams?: any): Observable<models.InlineResponse200> {
        return this.getAllIndexesWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Basic Search which gets all documents in `index_name` for provided search criteria
     * @param indexName Name of the index
     * @param q Search Query
     */
    public getBasicSearchResults(indexName: string, q: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2008> {
        return this.getBasicSearchResultsWithHttpInfo(indexName, q, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Fetches details of `doc_id` in `doc_type_name` for `index_name`
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     */
    public getDocument(indexName: string, docTypeName: string, docId: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2005> {
        return this.getDocumentWithHttpInfo(indexName, docTypeName, docId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Checks whether `document_type` in `index_name` exists
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     */
    public getDocumentType(indexName: string, docTypeName: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2003> {
        return this.getDocumentTypeWithHttpInfo(indexName, docTypeName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Checks whether `a particular index` {index_name} exists
     * @param indexName Name of the index
     */
    public getIndex(indexName: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2001> {
        return this.getIndexWithHttpInfo(indexName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Basic Search - Gets Suggestions from `doc_type_name` in `index_name`
     * @param indexName Name of the index
     * @param docTypeName Name of the Document_type
     * @param q Details of the suggest query
     */
    public getSuggestResults(indexName: string, docTypeName: string, q: string, extraHttpRequestParams?: any): Observable<models.InlineResponse2009> {
        return this.getSuggestResultsWithHttpInfo(indexName, docTypeName, q, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * 
     * Creates &#x60;doc_id&#x60; in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     * @param documentDetails Details of the document
     */
    public addDocumentWithHttpInfo(indexName: string, docTypeName: string, docId: string, documentDetails: any, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}/documents/${doc_id}'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName))
                    .replace('${' + 'doc_id' + '}', String(docId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling addDocument.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling addDocument.');
        }
        // verify required parameter 'docId' is not null or undefined
        if (docId === null || docId === undefined) {
            throw new Error('Required parameter docId was null or undefined when calling addDocument.');
        }
        // verify required parameter 'documentDetails' is not null or undefined
        if (documentDetails === null || documentDetails === undefined) {
            throw new Error('Required parameter documentDetails was null or undefined when calling addDocument.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: documentDetails == null ? '' : JSON.stringify(documentDetails), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Creates specific &#x60;document_type&#x60; in &#x60;index_name&#x60; with specified parameters
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docTypeDetails Details of the document_type
     */
    public addDocumentTypeWithHttpInfo(indexName: string, docTypeName: string, docTypeDetails: any, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling addDocumentType.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling addDocumentType.');
        }
        // verify required parameter 'docTypeDetails' is not null or undefined
        if (docTypeDetails === null || docTypeDetails === undefined) {
            throw new Error('Required parameter docTypeDetails was null or undefined when calling addDocumentType.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: docTypeDetails == null ? '' : JSON.stringify(docTypeDetails), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Creates &#x60;a new index&#x60;
     * @param indexName Name of the index
     */
    public addIndexWithHttpInfo(indexName: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}'
                    .replace('${' + 'index_name' + '}', String(indexName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling addIndex.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Deletes &#x60;doc_id&#x60; in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     */
    public deleteDocumentWithHttpInfo(indexName: string, docTypeName: string, docId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}/documents/${doc_id}'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName))
                    .replace('${' + 'doc_id' + '}', String(docId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling deleteDocument.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling deleteDocument.');
        }
        // verify required parameter 'docId' is not null or undefined
        if (docId === null || docId === undefined) {
            throw new Error('Required parameter docId was null or undefined when calling deleteDocument.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Deletes &#x60;an index&#x60; {index_name}
     * @param indexName Name of the index
     */
    public deleteIndexWithHttpInfo(indexName: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}'
                    .replace('${' + 'index_name' + '}', String(indexName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling deleteIndex.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Advanced Search which gets all documents in &#x60;index_name&#x60; for provided search criteria
     * @param indexName Name of the index
     * @param docTypeName Name of the Document)type
     * @param search Details of the search query
     */
    public getAdvancedSearchResultsWithHttpInfo(indexName: string, docTypeName: string, search: any, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}/search'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAdvancedSearchResults.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getAdvancedSearchResults.');
        }
        // verify required parameter 'search' is not null or undefined
        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling getAdvancedSearchResults.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (writeAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: search == null ? '' : JSON.stringify(search), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Gets &#x60;All document_types&#x60; present in &#x60;index_name&#x60;
     * @param indexName Name of the index
     */
    public getAllDocumentTypesWithHttpInfo(indexName: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types'
                    .replace('${' + 'index_name' + '}', String(indexName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAllDocumentTypes.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Fetches all documents in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     */
    public getAllDocumentsWithHttpInfo(indexName: string, docTypeName: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}/documents'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getAllDocuments.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getAllDocuments.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Fetches &#x60;All indexes&#x60;
     */
    public getAllIndexesWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Basic Search which gets all documents in &#x60;index_name&#x60; for provided search criteria
     * @param indexName Name of the index
     * @param q Search Query
     */
    public getBasicSearchResultsWithHttpInfo(indexName: string, q: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/search'
                    .replace('${' + 'index_name' + '}', String(indexName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getBasicSearchResults.');
        }
        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling getBasicSearchResults.');
        }
        if (q !== undefined) {
            queryParameters.set('q', <any>q);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Fetches details of &#x60;doc_id&#x60; in &#x60;doc_type_name&#x60; for &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     * @param docId Document ID
     */
    public getDocumentWithHttpInfo(indexName: string, docTypeName: string, docId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}/documents/${doc_id}'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName))
                    .replace('${' + 'doc_id' + '}', String(docId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getDocument.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getDocument.');
        }
        // verify required parameter 'docId' is not null or undefined
        if (docId === null || docId === undefined) {
            throw new Error('Required parameter docId was null or undefined when calling getDocument.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Checks whether &#x60;document_type&#x60; in &#x60;index_name&#x60; exists
     * @param indexName Name of the index
     * @param docTypeName Name of the document_type
     */
    public getDocumentTypeWithHttpInfo(indexName: string, docTypeName: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getDocumentType.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getDocumentType.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Checks whether &#x60;a particular index&#x60; {index_name} exists
     * @param indexName Name of the index
     */
    public getIndexWithHttpInfo(indexName: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}'
                    .replace('${' + 'index_name' + '}', String(indexName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getIndex.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Basic Search - Gets Suggestions from &#x60;doc_type_name&#x60; in &#x60;index_name&#x60;
     * @param indexName Name of the index
     * @param docTypeName Name of the Document_type
     * @param q Details of the suggest query
     */
    public getSuggestResultsWithHttpInfo(indexName: string, docTypeName: string, q: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/indexes/${index_name}/document_types/${doc_type_name}/suggest'
                    .replace('${' + 'index_name' + '}', String(indexName))
                    .replace('${' + 'doc_type_name' + '}', String(docTypeName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'indexName' is not null or undefined
        if (indexName === null || indexName === undefined) {
            throw new Error('Required parameter indexName was null or undefined when calling getSuggestResults.');
        }
        // verify required parameter 'docTypeName' is not null or undefined
        if (docTypeName === null || docTypeName === undefined) {
            throw new Error('Required parameter docTypeName was null or undefined when calling getSuggestResults.');
        }
        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling getSuggestResults.');
        }
        if (q !== undefined) {
            queryParameters.set('q', <any>q);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (authToken) required
        if (this.configuration.apiKey) {
            queryParameters.set('auth_token', this.configuration.apiKey);
        }

        // authentication (readAppID) required
        if (this.configuration.apiKey) {
            headers.set('X-RSearch-App-ID', this.configuration.apiKey);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
